% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Matched.R, R/MatchedSummarizedExperiment.R
\name{Matched}
\alias{Matched}
\alias{Matched-class}
\alias{[,Matched-method}
\alias{MatchedSummarizedExperiment}
\alias{MatchedSummarizedExperiment-class}
\alias{length,Matched-method}
\alias{show,Matched-method}
\alias{[,Matched,ANY,ANY,ANY-method}
\alias{target}
\alias{query}
\alias{whichTarget}
\alias{whichQuery}
\alias{$,Matched-method}
\alias{colnames,Matched-method}
\alias{matchedData}
\alias{matchedData,Matched-method}
\alias{pruneTarget}
\alias{filterMatches}
\alias{filterMatches,Matched-method}
\alias{addMatches}
\alias{addMatches,Matched-method}
\title{Representation of generic objects matches}
\usage{
Matched(
  query = list(),
  target = list(),
  matches = data.frame(query_idx = integer(), target_idx = integer(), score =
    numeric())
)

\S4method{length}{Matched}(x)

\S4method{show}{Matched}(object)

\S4method{[}{Matched,ANY,ANY,ANY}(x, i, j, ..., drop = FALSE)

target(object)

query(object)

whichTarget(object)

whichQuery(object)

\S4method{$}{Matched}(x, name)

\S4method{colnames}{Matched}(x)

matchedData(object, ...)

\S4method{matchedData}{Matched}(object, columns = colnames(object), ...)

pruneTarget(object)

filterMatches(object, ...)

\S4method{filterMatches}{Matched}(
  object,
  queryValues = integer(),
  targetValues = integer(),
  queryColname = character(),
  targetColname = character(),
  idxs = integer(),
  keep = TRUE,
  ...
)

addMatches(object, ...)

\S4method{addMatches}{Matched}(
  object,
  queryValues = integer(),
  targetValues = integer(),
  queryColname = character(),
  targetColname = character(),
  scores = data.frame(),
  isIndex = FALSE
)

MatchedSummarizedExperiment(
  query = SummarizedExperiment(),
  target = data.frame(),
  matches = data.frame(query_idx = integer(), target_idx = integer(), score =
    numeric())
)
}
\arguments{
\item{query}{object with the query elements.}

\item{target}{object with the elements against which \code{query} has been
matched.}

\item{matches}{\code{data.frame} with columns \code{"query_idx"} (\code{integer}),
\code{"target_idx"} (\code{integer}) and \code{"score"} (\code{numeric}) representing the n:m
mapping of elements between the \code{query} and the \code{target} objects.}

\item{x}{\code{Matched} object.}

\item{object}{a \code{Matched} object.}

\item{i}{\code{integer} or \code{logical} defining the \code{query} elements to keep.}

\item{j}{for \code{[}: ignored.}

\item{...}{additional parameters.}

\item{drop}{for \code{[}: ignored.}

\item{name}{for \code{$}: the name of the column (or variable) to extract.}

\item{columns}{for \code{matchedData}: \code{character} vector with column names of
variables that should be extracted.}

\item{queryValues}{vector of values to search for in \code{query} (if \code{query}
is 1-dimensional) or in column \code{queryColname} of \code{query} (if \code{query} is
2-dimensional). This parameter can be used in \code{filterMatches}
and when it is used also the parameter \code{targetValues} must be passed.
\code{filterMatches} will return a \code{Matched} object with only the matches whose
\code{query} and  \code{target} values are equal respectivly to \code{targetValues[i]} and
\code{queryValues[i]} for some i.}

\item{targetValues}{vector of values to search for in \code{target} (if \code{target}
is 1-dimensional) or in column \code{targetColname} of \code{target} (if \code{target} is
2-dimensional).}

\item{queryColname}{if \code{query} is 2-dimensional: column of \code{query} against
which elements of \code{queryValues} are compared.}

\item{targetColname}{if \code{query} is 2-dimensional: column of \code{target} against
which elements of \code{targetValues} are compared.}

\item{idxs}{for \code{filterMatches}: indexes of the matches to keep (if
\code{keep = TRUE}) or to drop if (\code{keep = FALSE}).}

\item{keep}{for \code{filterMatches}: \code{logical}. If \code{keep = TRUE} the matches are
kept, if \code{keep = FALSE} they are removed.}

\item{scores}{for \code{addMatches}: data.frame specifying the scores for the
matches to add.}

\item{isIndex}{for \code{addMatches}: specifies if \code{queryValues} and
\code{targetValues} are expected to be vectors of indexes.}
}
\value{
See individual method description above for details.
}
\description{
Matches between query and target generic objects can be represented by the
\code{Matched} object. By default, all data accessors work as
\emph{left joins} between the \emph{query} and the \emph{target} object, i.e. values are
returned for each \emph{query} object with eventual duplicated entries (values)
if the query object matches more than one target object. See also
\emph{Creation and subsetting} as well as \emph{Extracting data} sections below for
details and more information

The \code{MatchedSummarizedExperiment} object allows to represent matches between
a \code{\link[=SummarizedExperiment]{SummarizedExperiment()}} object against a \emph{target} object (which can be,
like for the \code{Matched} object, a \code{data.frame}, \code{matrix}, \code{vector} or \code{list}).
Matches represent links between rows of this \code{SummarizedExperiment} to the
target, hence, \code{colnames} and \code{matchedData} will access the \code{\link[=rowData]{rowData()}} of
the matched \code{SummarizedExperiment}.
}
\section{Creation and subsetting}{


\code{Matched} and \code{MatchedSummarizedExperiment} objects are returned as result
from the \code{\link[=matchMz]{matchMz()}} function.

Alternatively, \code{Matched} objects can also be created with the \code{Matched}
function providing the \code{query} and \code{target} object as well as the \code{matches}
\code{data.frame} with two columns of integer indices defining which elements
from \emph{query} match which element from \emph{target}.

\code{MatchedSummarizedExperiment} objects can be created with the
\code{MatchedSummarizedExperiment} function providing the \code{SummarizedExperiment}
with the \code{query} parameter.

A \code{Matched} or \code{MatchedSummarizedExperiment} object can be subsetted in the
following ways:
\itemize{
\item \code{[} subset the object selecting \code{query} object elements to keep with
parameter \code{i}. The resulting object will contain all the matches
for the selected query elements. The \code{target} object will by default be
returned as-is.
\item \code{pruneTarget} \emph{cleans} the object by removing non-matched
\strong{target} elements.
\item \code{filterMatches} keeps only the matches corresponding to certain indexes or
values of \code{query} and \code{target}.
}

It is possible to add new matches to a \code{Matched} or
\code{MatchedSummarizedExperiment} object via \code{addMatches}. With parameters
\code{queryValues} and \code{targetValues} it is possible to specify values of \code{query}
and \code{target} (if they are 1-dimensional) or one of their columns (specified
with parameters \code{queryColname} or \code{targetColname}) and these values are used
to establish new matches. By using parameter \code{isIndex} it is possible to
interpret \code{queryValues} and \code{targetValues} as vector of indexes of the
elements of \code{query} and \code{target} to be matched together.
}

\section{Extracting data}{

\itemize{
\item \code{$} extracts a single variable from the \code{Matched} \code{x}. The variables that
can be extracted can be listed using \code{colnames(x)}. These variables can
belong to \emph{query}, \emph{target} or be related to the matches (e.g. the
score of each match). If the \emph{query} (\emph{target}) object is two dimensional,
its columns can be extracted (prefix\code{ "target_"} is used for columns in the
\emph{target} object) otherwise (if \emph{query} respectively \emph{target} does have only
a single dimension (e.g. is a \code{list} or a \code{character}) the whole object can
is extracted with \code{x$query} (\code{x$target}).
The matching scores are available as \emph{variable}
\code{"score"}. Similar to a left join between the query and target elements,
this function returns a value for each query element, with eventual
duplicated values for query elements matching more than one target element.
If variables from the target \code{data.frame} are extracted, an \code{NA} is
reported for the entries corresponding to \emph{query} elements that don't match
any target element. See examples below for more details.
For \code{MatchedSummarizedExperiment} columns in the object's \code{rowData} are
used as query columns and returned.
\item \code{length} returns the number of \strong{query} elements.
\item \code{matchedData} allows to extract multiple variables contained in the
\code{Matched} object as a \code{DataFrame}. Parameter \code{columns} allows to
define which columns (or variables) should be returned (defaults to
\code{columns = colnames(object)}). Each single column in the returned
\code{DataFrame} is constructed in the same way as in \code{$}. That is, like \code{$},
this function performs a \emph{left join} of variables from the \emph{query} and
\emph{target} objects returning all values for all query elements (eventually
returning duplicated elements for query elements matching multiple target
elements) and the values for the target elements matched to the respective
query elements (or \code{NA} if the target element is not matched to any query
element). For \code{MatchedSummarizedExperiment} the object's \code{rowData} is used
as the \emph{query} data frame.
\item \code{target} returns the \emph{target} object.
\item \code{query} returns the \emph{query} object.
\item \code{whichTarget} returns an \code{integer} with the indices of the elements in
\emph{target} that match at least one element in \emph{query}.
\item \code{whichQuery} returns an \code{integer} with the indices of the elements in
\emph{query} that match at least one element in \emph{target}.
}
}

\examples{

## Creating a Matched object.
q1 <- data.frame(col1 = 1:5, col2 = 6:10)
t1 <- data.frame(col1 = 11:16, col2 = 17:22)
## Define matches between query row 1 with target row 2 and, query row 2
## with target rows 2,3,4 and query row 5 with target row 5.
mo <- Matched(
    q1, t1, matches = data.frame(query_idx = c(1L, 2L, 2L, 2L, 5L),
                                target_idx = c(2L, 2L, 3L, 4L, 5L),
                                 score = seq(0.5, 0.9, by = 0.1)))
mo

## Which of the query elements (rows) match at least one target
## element (row)?
whichQuery(mo)

## Which target elements (rows) match at least one query element (row)?
whichTarget(mo)

## Extracting variable "col1" from query object .
mo$col1

## We have duplicated values for the entries of `col1` related to query
## elements (rows) matched to multiple rows of the target object). The
## value of `col1` is returned for each element (row) in the query.

## Extracting variable "col1" from target object. To access columns from
## target we have to prefix the name of the column by `"target_"`.
## Note that only values of `col1` for rows matching at least one query
## row are returned and an NA is reported for query rows without matching
## target rows.
mo$target_col1

## The 3rd and 4th query rows do not match any target row, thus `NA` is
## returned.

## `matchedData` can be used to extract all (or selected) columns
## from the object. Same as with `$`, a left join between the columns
## from the query and the target is performed. Below we extract selected
## columns from the object as a DataFrame.
res <- matchedData(mo, columns = c("col1", "col2", "target_col1", "target_col2"))
res
res$col1
res$target_col1

## The example matched object contains all query and all target
## elements (rows). Below we subset the object keeping only query rows that
## are matched to at least one target row.
mo_sub <- mo[whichQuery(mo)]

## mo_sub contains now only 3 query rows:
nrow(query(mo_sub))

## while the original object contains all 5 query rows:
nrow(query(mo))

## Both objects contain however still the full target object:
nrow(target(mo))
nrow(target(mo_sub))

## With the `pruneTarget` we can however reduce also the target rows to
## only those that match at least one query row
mo_sub <- pruneTarget(mo_sub)
nrow(target(mo_sub))

## Creating a Matched object with a `data.frame` for `query` and a `vector`
## for `target`. The matches are specified in the same way as the example
## before.

q1 <- data.frame(col1 = 1:5, col2 = 6:10)
t2 <- 11:16
mo <- Matched(q1, t2, matches = data.frame(query_idx = c(1L, 2L, 2L, 2L, 5L),
    target_idx = c(2L, 2L, 3L, 4L, 5L), score = seq(0.5, 0.9, by = 0.1)))

## *target* is a simple vector and has thus no columns. The matched values
## from target, if it does not have dimensions and hence column names, can
## be retrieved with `$target`
mo$target

## Note that in this case "target" is returned by the function `colnames`
colnames(mo)

## As before, we can extract all data as a `DataFrame`
res <- matchedData(mo)
res

## Note that the columns of the obtained `DataFrame` are the same as the
## corresponding vectors obtained with `$`

res$col1
res$target

## Also subsetting and pruning works in the same way as the example above.

mo_sub <- mo[whichQuery(mo)]

## mo_sub contains now only 3 query rows:
nrow(query(mo_sub))

## while the original object contains all 5 query rows:
nrow(query(mo))

## Both object contain however still the full target object:
length(target(mo))
length(target(mo_sub))

## Reducing the target elements to only those that match at least one query row
mo_sub <- pruneTarget(mo_sub)
nrow(target(mo_sub))

## Keeping only certain matches through their indexes 
idxs <- c(1, 3, 5)
mosub <- filterMatches(mo, idxs = idxs)
mosub@matches
mo@matches[-idxs, ]

## Keeping matches corresponding to certain values of query and target
queryValues <- c(q1[mo@matches[idxs, "query_idx"], "col1"], -1, - 2)
targetValues <- c(t2[mo@matches[idxs, "target_idx"]], -2, -1)
mosub <- filterMatches(mo, queryValues = queryValues, 
                     targetValues = targetValues, queryColname = "col1")
mosub@matches

## Removing matches using values of query and target
mosub <- filterMatches(mo, keep = FALSE, queryValues = queryValues, 
                     targetValues = targetValues, queryColname = "col1")
mosub@matches

## Manually adding matches using values of "col1" column in query and of 
target
moadd <- addMatches(mo, queryValues = q1[c(3, 5), "col1"],
                    targetValues = t2[c(1, 6)], queryColname = "col1",
                    scores = data.frame(score = c(1, 1.1)))
#' ## Manually adding matches using indexes of query and target values to match
moadd <- addMatches(mo, queryValues = c(3L, 5L), targetValues = c(1L, 6L),
                    scores = data.frame(score = c(1, 1.1)), isIndex = TRUE)

## Creating a MatchedSummarizedExperiment object.
library(SummarizedExperiment)
q1 <- SummarizedExperiment(
  assays = data.frame(matrix(NA, 5, 2)),
  rowData = data.frame(col1 = 1:5, col2 = 6:10),
  colData = data.frame(cD1 = c(NA, NA), cD2 = c(NA, NA)))
t1 <- data.frame(col1 = 11:16, col2 = 17:22)
## Define matches between row 1 in rowData(q1) with target row 2 and,
## rowData(q1) row 2 with target rows 2,3,4 and rowData(q1) row 5 with target
## row 5.
mo <- MatchedSummarizedExperiment(
    q1, t1, matches = data.frame(query_idx = c(1L, 2L, 2L, 2L, 5L),
                                target_idx = c(2L, 2L, 3L, 4L, 5L),
                                 score = seq(0.5, 0.9, by = 0.1)))
mo

## Which of the query elements (rows) match at least one target
## element (row)?
whichQuery(mo)

## Which target elements (rows) match at least one query element (row)?
whichTarget(mo)

## Extracting variable "col1" from rowData(q1).
mo$col1

## We have duplicated values for the entries of `col1` related to rows of
## rowData(q1) matched to multiple rows of the target data.frame t1. The
## value of `col1` is returned for each row in the rowData of query.

## Extracting variable "col1" from target object. To access columns from
## target we have to prefix the name of the column by `"target_"`.
## Note that only values of `col1` for rows matching at least one row in
## rowData of query are returned and an NA is reported for those without
## matching target rows.
mo$target_col1

## The 3rd and 4th query rows do not match any target row, thus `NA` is
## returned.

## `matchedData` can be used to extract all (or selected) columns
## from the object. Same as with `$`, a left join between the columns
## from the query and the target is performed. Below we extract selected
## columns from the object as a DataFrame.
res <- matchedData(mo, columns = c("col1", "col2", "target_col1", "target_col2"))
res
res$col1
res$target_col1

## The example MatchedSummarizedExperiment object contains all rows in the
## rowData of the SummarizedExperiment and all target rows. Below we subset the
## object keeping only rows that are matched to at least one target row.
mo_sub <- mo[whichQuery(mo)]

## mo_sub contains now a SummarizedExperiment with only 3 rows:
nrow(query(mo_sub))

## while the original object contains a SummarizedExperiment with all 5 rows:
nrow(query(mo))

## Both objects contain however still the full target object:
nrow(target(mo))
nrow(target(mo_sub))

## With the `pruneTarget` we can however reduce also the target rows to
## only those that match at least one in the rowData of query
mo_sub <- pruneTarget(mo_sub)
nrow(target(mo_sub))
}
\seealso{
\code{\link[=MatchedSpectra]{MatchedSpectra()}} for matched \code{\link[=Spectra]{Spectra()}} objects.
}
\author{
Andrea Vicini, Johannes Rainer
}
